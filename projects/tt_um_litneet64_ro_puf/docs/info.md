<!---

This file is used to generate your project datasheet. Please fill in the information below and delete any unused
sections.

You can also include images in this folder and reference them in the markdown. Each image must be less than
512 kb in size, and the combined size of all images must be less than 1 MB.
-->

## How it works

A physical unclonable function (PUF) is a hardware primitive that maps an input (called a challenge) to an output (called a response) in a similar fashion to a hash function. The goal of a PUF can be many: uniquely identifying an integrated circuit (IC) from another while still keeping deterministic outputs for the same IC, using a set of challenge-response pairs (CRP); generating random-enough nonces; or even authenticating an IC (stronger version of identification). In order to evaluate its performance for those goals, relevant metrics such as **uniqueness**, **reliability**, **uniformity** and **entropy** of CRPs over many PUF ICs are commonly employed. The PUF implementation for this project uses many identical, 7-inverter ring oscillators (RO) which introduce randomness or variation in their operating frequencies at the time of the fabrication process itself. 

![](ro_puf_1bit_block.png)

In this case, an 8-bit parallel architecture for each bit of a CR
P is adopted. The 8-bit challenge is shared along 8 independent blocks in order to derive only 1-bit of the response per block. One PUF block contains 32 ROs, where one RO is selected between the top half of the ROs over a challenge-dependent 16-bit mux, while other RO is selected from the remaining bottom half over the second chall-dependent 16-bit mux. Then, both muxes connect directly to 1 counter of its own. Both of the counters then race each other until a given threshold (65535 in this case) is reached, and an arbiter module that's connected to both counters declares the winner in a 1-bit response.

![](ro_puf_8bit.png)

## How to test

Start by feeding an 8-bit challenge to the 8 input pins in the Tiny Tapeout board before enabling or selecting this module. This will ensure that the appropiate input data is sampled while initiating the ring oscillators. After some milliseconds, a result should appear at the 8 output pins as individual response bits. To generate another CRP without powering-off the board, first start sending the new challenge on the input pins continously. After it, drive the reset pin high and then immediately low in order to sample the newest input values. Note that the output or responses **may** change as the device reaches operational temperature, after which they will become consistent. This instability is due to the ROs' sensitivity to temperature, which will slightly change frequency operation.

**EXTRA**: In order to accurately estimate entropy, uniqueness, reliability and uniformity for this PUF architecture in Sky130, **a lot** of measurements must be taken to ensure unbiased representation of data and validity of the metric's results. That's why the module's author needs you, a Tiny Tapeout board owner, to join in this open-source effort of characterizing this manufacturing process and PUF architecture. The required data to collect would be the set of all possible 8-bit Challenge-Response Pairs (CRP) generated by your specific device. For more information on how to help and where to register your CRPs, check the GitHub repo related to this project. The plan is to make this data and the metrics transparent and public, updating them in real time.


## External hardware

No external hardware is required for this project.
